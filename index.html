<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Timeline Visualizer - project_üëç</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', monospace; }
        body { background: linear-gradient(135deg, #0a1929 0%, #1a1a2e 100%); color: #e0e0e0; min-height: 100vh; }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 350px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 15px;
            padding: 20px;
        }
        
        .header {
            grid-column: 1 / -1;
            background: rgba(20, 30, 48, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h1 {
            background: linear-gradient(90deg, #00b4db, #0083b0);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .timeline-area {
            background: rgba(15, 25, 40, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            position: relative;
            overflow: hidden;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }
        
        .timeline-container {
            position: relative;
            height: 400px;
            margin-top: 30px;
            overflow: hidden;
            border-radius: 15px;
            background: rgba(15, 25, 40, 0.3);
        }
        
        .branch-visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease;
            z-index: 1;
        }
        
        .commit-nodes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease;
            z-index: 2;
        }
        
        .timeline-connections {
            stroke: #4ecdc4;
            stroke-width: 2;
            opacity: 0.6;
        }
        
        .timeline-log-container {
            background: rgba(20, 30, 48, 0.6);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            height: 400px;
            margin-top: 30px;
            overflow-y: auto;
        }
        
        .timeline-log-container h3 {
            color: #4ecdc4;
            margin: 0 0 20px 0;
            font-size: 1.1rem;
            border-bottom: 2px solid rgba(78, 205, 196, 0.3);
            padding-bottom: 10px;
        }
        
        .timeline-log {
            position: relative;
            padding-left: 30px;
        }
        
        .timeline-log::before {
            content: '';
            position: absolute;
            left: 15px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, #4ecdc4, #764ba2);
        }
        
        .log-entry {
            position: relative;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(30, 40, 60, 0.4);
            border-radius: 10px;
            border-left: 4px solid #4ecdc4;
            transition: all 0.3s ease;
        }
        
        .log-entry:hover {
            background: rgba(30, 40, 60, 0.6);
            transform: translateX(5px);
        }
        
        .log-entry::before {
            content: '';
            position: absolute;
            left: -23px;
            top: 20px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4ecdc4;
            border: 2px solid rgba(15, 25, 40, 0.8);
            z-index: 1;
        }
        
        .log-entry.commit {
            border-left-color: #51cf66;
        }
        
        .log-entry.commit::before {
            background: #51cf66;
        }
        
        .log-entry.branch {
            border-left-color: #ff9ff3;
        }
        
        .log-entry.branch::before {
            background: #ff9ff3;
        }
        
        .log-entry.merge {
            border-left-color: #feca57;
        }
        
        .log-entry.merge::before {
            background: #feca57;
        }
        
        .log-entry.remote {
            border-left-color: #ff6b6b;
        }
        
        .log-entry.remote::before {
            background: #ff6b6b;
        }
        
        .log-time {
            font-size: 0.8rem;
            color: #96ceb4;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .log-command {
            font-size: 0.9rem;
            color: #74c0fc;
            margin-bottom: 5px;
            font-family: 'Courier New', monospace;
        }
        
        .log-description {
            font-size: 0.85rem;
            color: #e0e0e0;
            line-height: 1.4;
        }
        
        .no-logs {
            text-align: center;
            color: #666;
            padding: 40px 20px;
            font-style: italic;
        }
        
        .commit-nodes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }
        
        .commit-node {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border: 3px solid #0a1929;
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
            cursor: pointer;
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
            z-index: 11;
            pointer-events: auto;
        }
        
        .commit-node.merge {
            background: linear-gradient(135deg, #ff9ff3, #f368e0);
            box-shadow: 0 0 15px rgba(255, 159, 243, 0.5);
        }
        
        .commit-node.branch-commit {
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }
        
        .commit-label {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 30, 48, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            white-space: nowrap;
            border: 1px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 12;
            min-width: 200px;
            text-align: center;
        }
        
        .commit-node:hover .commit-label {
            opacity: 1;
        }
        
        .branch-visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }
        
        .branch-label {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 107, 107, 0.9);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            white-space: nowrap;
            z-index: 6;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .stages-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
            padding: 20px;
            background: rgba(10, 25, 41, 0.6);
            border-radius: 15px;
            /* border: 1px solid rgba(100, 150, 255, 0.2); */
        }
        
        .stage {
            background: rgba(30, 40, 60, 0.6);
            border-radius: 12px;
            padding: 15px;
            min-height: 240px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .stage.active { border-color: #4ecdc4; box-shadow: 0 0 20px rgba(78, 205, 196, 0.3); }
        
        .control-panel {
            background: rgba(20, 30, 48, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 100vh;
            overflow-y: auto;
        }
        
        .command-section h3 {
            color: #4ecdc4;
            margin: 0 0 15px 0;
            font-size: 1.1rem;
            border-bottom: 1px solid rgba(100, 150, 255, 0.3);
            padding-bottom: 8px;
        }
        
        .main-commands {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-bottom: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .main-cmd-btn {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            background: rgba(30, 40, 60, 0.6);
            color: #e0e0e0;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .main-cmd-btn:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: #4ecdc4;
            transform: translateY(-1px);
        }
        
        .main-cmd-btn.active {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border-color: #4ecdc4;
            color: white;
            box-shadow: 0 2px 10px rgba(78, 205, 196, 0.3);
        }
        
        .auxiliary-commands {
            background: rgba(10, 25, 41, 0.6);
            border-radius: 10px;
            padding: 15px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .auxiliary-commands h4 {
            color: #96ceb4;
            margin: 0 0 10px 0;
            font-size: 0.9rem;
        }
        
        .aux-cmd-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 6px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            background: rgba(40, 50, 70, 0.4);
            color: #e0e0e0;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }
        
        .aux-cmd-btn:hover {
            background: rgba(78, 205, 196, 0.15);
            border-color: rgba(78, 205, 196, 0.5);
        }
        
        .command-input-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .command-input-container input {
            flex: 1;
            padding: 12px 15px;
            border-radius: 10px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            background: rgba(0, 0, 0, 0.4);
            color: white;
            font-size: 0.9rem;
            font-family: 'Monaco', 'Consolas', monospace;
        }
        
        .execute-btn {
            padding: 12px 20px;
            border-radius: 10px;
            border: none;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .execute-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }
        
        .terminal-section {
            border-top: 1px solid rgba(100, 150, 255, 0.2);
            padding-top: 15px;
        }
        
        .terminal-toggle {
            width: 100%;
            padding: 12px;
            border-radius: 10px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            background: rgba(30, 40, 60, 0.6);
            color: #e0e0e0;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .terminal-toggle:hover {
            background: rgba(78, 205, 196, 0.2);
            border-color: #4ecdc4;
        }
        
        .terminal {
            grid-column: 1 / -1;
            background: rgba(10, 15, 25, 0.95);
            border-radius: 15px;
            padding: 0;
            border: 1px solid rgba(100, 150, 255, 0.2);
            height: 300px;
            min-height: 150px;
            max-height: 80vh;
            display: flex;
            width: 70vw;
            max-width: 70vw;
            margin: 0 auto;
            flex-direction: column;
            transition: all 0.3s ease;
            transform-origin: top;
            resize: vertical;
            overflow: auto;
        }
        
        .terminal.minimized {
            height: 0;
            opacity: 0;
            margin-bottom: -200px;
            resize: none;
        }
        
        .terminal.expanded {
            height: 400px;
            width: 70vw;
            max-width: 70vw;
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            resize: both;
            overflow: auto;
        }
        
        .terminal-resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, transparent, rgba(78, 205, 196, 0.5), transparent);
            cursor: ns-resize;
            border-radius: 0 0 15px 15px;
        }
        
        .terminal.expanded .terminal-resize-handle {
            cursor: nwse-resize;
        }
        
        .terminal-header {
            background: rgba(20, 30, 48, 0.8);
            padding: 10px 20px;
            border-bottom: 1px solid rgba(100, 150, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .terminal-title {
            color: #4ecdc4;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .terminal-controls {
            display: flex;
            gap: 10px;
        }
        
        .terminal-controls button {
            background: rgba(255, 107, 107, 0.8);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .terminal-controls button:hover {
            background: rgba(255, 107, 107, 1);
        }
        
        .terminal-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        /* Terminal output color coding */
        .terminal-line {
            margin-bottom: 5px;
            word-wrap: break-word;
        }
        
        .terminal-line.command {
            color: #4A90E2; /* Blue for commands */
            font-weight: bold;
        }
        
        .terminal-line.success {
            color: #4CAF50; /* Green for success */
        }
        
        .terminal-line.error {
            color: #F44336; /* Red for errors */
        }
        
        .terminal-line.info {
            color: #FF9800; /* Orange for info */
        }
        
        .terminal-line.warning {
            color: #FFC107; /* Yellow for warnings */
        }
        
        .terminal-input-line {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            border-top: 1px solid rgba(100, 150, 255, 0.2);
            background: rgba(20, 30, 48, 0.6);
        }
        
        .terminal-prompt {
            color: #4ecdc4;
            margin-right: 10px;
            font-family: 'Monaco', 'Consolas', monospace;
        }
        
        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9rem;
            outline: none;
        }
        
        /* Storage area styles */
        .file-list {
            list-style: none;
            padding: 10px;
            margin: 0;
            max-height: 180px;
            overflow-y: auto;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 3px solid #4ecdc4;
            transition: all 0.2s ease;
        }
        
        .file-item:hover {
            background: rgba(78, 205, 196, 0.1);
            transform: translateX(2px);
        }
        
        .file-item i {
            color: #4ecdc4;
            margin-right: 10px;
            font-size: 0.8rem;
        }
        
        .file-name {
            flex: 1;
            font-size: 0.85rem;
            color: #e0e0e0;
        }
        
        .file-message {
            font-size: 0.75rem;
            color: #96ceb4;
            margin-left: 10px;
            font-style: italic;
        }
        
        .file-author {
            font-size: 0.7rem;
            color: #64748b;
            margin-left: 10px;
        }
        
        .empty-stage {
            text-align: center;
            color: #64748b;
            font-style: italic;
            padding: 20px;
            font-size: 0.85rem;
        }
        
        .stage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .stage-title {
            font-weight: bold;
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        
        .file-count {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
        }
        
        .file-count-mini {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
            padding: 1px 6px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: bold;
            margin-left: 8px;
        }
        
        .file-name.staged {
            color: #4CAF50;
            font-weight: 500;
        }
        
        .file-name.modified {
            color: #FF9800;
        }
        
        /* Command node styles */
        .command-node {
            position: absolute;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .command-node:hover {
            z-index: 100;
        }
        
        .command-node.selected {
            z-index: 50;
        }
        
        .command-node.selected .command-dot {
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.8);
            border-color: #2a7f7e;
        }
        
        .command-node.selected .command-info {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }
        
        .command-node.current-head {
            z-index: 10;
        }
        
        .command-dot {
            width: 16px;
            height: 16px;
            background: #4ecdc4;
            border: 3px solid #2a7f7e;
            border-radius: 50%;
            margin: 0 auto 8px;
            position: relative;
        }
        
        /* Different command type colors */
        .command-init .command-dot { background: #4CAF50; border-color: #2E7D32; }
        .command-add .command-dot { background: #2196F3; border-color: #1565C0; }
        .command-commit .command-dot { background: #FF9800; border-color: #F57C00; }
        .command-branch .command-dot { background: #9C27B0; border-color: #6A1B9A; }
        .command-switch .command-dot { background: #E91E63; border-color: #C2185B; }
        .command-merge .command-dot { background: #00BCD4; border-color: #0097A7; }
        .command-remote .command-dot { background: #795548; border-color: #4E342E; }
        .command-pull .command-dot { background: #607D8B; border-color: #455A64; }
        .command-push .command-dot { background: #FF5722; border-color: #D84315; }
        .command-config .command-dot { background: #FFC107; border-color: #F57F17; }
        .command-log .command-dot { background: #9E9E9E; border-color: #616161; }
        .command-reset .command-dot { background: #F44336; border-color: #C62828; }
        .command-status .command-dot { background: #009688; border-color: #00695C; }
        
        .command-node.current-head .command-dot {
            background: #FFD700;
            border-color: #FFA000;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .command-info {
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 8px;
            padding: 8px;
            min-width: 100px;
            font-size: 0.7rem;
            transition: all 0.3s ease;
            opacity: 0.9;
        }
        
        .command-type {
            color: #4ecdc4;
            font-weight: bold;
            font-family: monospace;
            font-size: 0.6rem;
        }
        
        .commit-hash {
            color: #FF9800;
            font-weight: bold;
            font-family: monospace;
        }
        
        .command-message {
            color: #e0e0e0;
            margin: 4px 0;
            font-weight: 500;
            white-space: normal;
            word-wrap: break-word;
            max-width: 100px;
            line-height: 1.2;
        }
        
        .command-text {
            color: #96ceb4;
            font-size: 0.6rem;
            font-family: monospace;
        }
        
        .no-commits {
            text-align: center;
            color: #64748b;
            font-style: italic;
            padding: 40px;
            font-size: 1.1rem;
        }
        
        /* Add more styles from the previous HTML file as needed */
        
        /* Git Graph Visualization Styles */
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .git-commit-node {
            font-family: 'Segoe UI', monospace;
        }
        
        .timeline-container {
            position: relative;
            height: 400px;
            overflow: auto;
            border-radius: 15px;
            background: rgba(15, 25, 40, 0.3);
            min-width: 800px;
        }
        
        .branch-visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: auto;
            cursor: grab;
        }
        
        .branch-visualizer:active {
            cursor: grabbing;
        }
        
        .commit-nodes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        .commit-nodes .git-commit-node {
            pointer-events: auto;
        }
        
        .graph-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            gap: 5px;
            background: rgba(20, 30, 48, 0.9);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .graph-control-btn {
            background: rgba(78, 205, 196, 0.2);
            border: 1px solid rgba(78, 205, 196, 0.3);
            color: #4ecdc4;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .graph-control-btn:hover {
            background: rgba(78, 205, 196, 0.3);
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-code-branch"></i> Git Timeline Visualizer</h1>
            <div class="project-info">
                <div class="project-badge">project_üëç</div>
                <div class="git-status" id="git-status">
                    <span id="current-branch">No repository</span>
                    <span id="commit-count"></span>
                </div>
            </div>
        </div>

        <div class="timeline-area">
            <div class="timeline-container">
                <svg class="branch-visualizer" id="branch-visualizer" width="100%" height="100%"></svg>
                <div class="commit-nodes" id="commit-nodes"></div>
                <div class="graph-controls">
                    <button class="graph-control-btn" onclick="zoomIn()">+</button>
                    <button class="graph-control-btn" onclick="zoomOut()">‚àí</button>
                    <button class="graph-control-btn" onclick="resetZoom()">‚ü≤</button>
                    <button class="graph-control-btn" onclick="centerGraph()">‚äô</button>
                </div>
            </div>
            
            <div class="timeline-log-container">
                <h3>üìú Timeline Log</h3>
                <div class="timeline-log" id="timeline-log">
                    <div class="no-logs">No Git commands executed yet.</div>
                </div>
            </div>
            
            <div class="stages-container" style="grid-column: 1 / -1;">
                <div class="stage stage-1" id="stage-working">
                    <div class="stage-header">
                        <div class="stage-title">üìÅ Working Directory</div>
                        <span class="file-count">0</span>
                    </div>
                    <ul class="file-list" id="working-files"></ul>
                </div>
                
                <div class="stage stage-2" id="stage-staging">
                    <div class="stage-header">
                        <div class="stage-title">üì§ Staging Area</div>
                        <span class="file-count">0</span>
                    </div>
                    <ul class="file-list" id="staged-files"></ul>
                </div>
                
                <div class="stage stage-3" id="stage-local">
                    <div class="stage-header">
                        <div class="stage-title">üíæ Local Repository</div>
                        <span class="file-count">0</span>
                    </div>
                    <ul class="file-list" id="committed-files"></ul>
                </div>
                
                <div class="stage stage-4" id="stage-remote">
                    <div class="stage-header">
                        <div class="stage-title">üåê Remote Repository</div>
                        <span class="file-count">0</span>
                    </div>
                    <ul class="file-list" id="remote-files"></ul>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <div class="command-section">
                <h3>Git Commands</h3>
                <div class="main-commands">
                    <button class="main-cmd-btn active" data-cmd="init">git init</button>
                    <button class="main-cmd-btn" data-cmd="add">git add</button>
                    <button class="main-cmd-btn" data-cmd="commit">git commit</button>
                    <button class="main-cmd-btn" data-cmd="branch">git branch</button>
                    <button class="main-cmd-btn" data-cmd="switch">git switch</button>
                    <button class="main-cmd-btn" data-cmd="merge">git merge</button>
                    <button class="main-cmd-btn" data-cmd="remote">git remote</button>
                    <button class="main-cmd-btn" data-cmd="pull">git pull</button>
                    <button class="main-cmd-btn" data-cmd="push">git push</button>
                    <button class="main-cmd-btn" data-cmd="config">git config</button>
                    <button class="main-cmd-btn" data-cmd="log">git log</button>
                    <button class="main-cmd-btn" data-cmd="reset">git reset</button>
                    <button class="main-cmd-btn" data-cmd="clone">git clone</button>
                </div>
                
                <div class="auxiliary-commands" id="auxiliary-commands">
                    <!-- Auxiliary commands will be populated here -->
                    <h4>git init</h4>
                    <button class="aux-cmd-btn" onclick="executeCommand('git init .')">git init .</button>
                </div>
                
                <!-- <div class="command-input-container">
                    <input type="text" id="git-command" placeholder="Enter Git command..." autocomplete="off">
                    <button class="execute-btn" onclick="executeCommand()">Execute</button>
                </div> -->
            </div>
            
            <div class="terminal-section">
                <button class="terminal-toggle" onclick="toggleTerminal()">
                    <i class="fas fa-terminal"></i> Terminal
                </button>
            </div>
        </div>

        <div class="terminal minimized" id="terminal">
            <div class="terminal-header">
                <div class="terminal-title">üñ•Ô∏è Terminal - project_üëç</div>
                <div class="terminal-controls">
                    <button onclick="clearTerminal()">Clear</button>
                    <button onclick="toggleTerminal()">Minimize</button>
                </div>
            </div>
            <div class="terminal-content" id="terminal-output"></div>
            <div class="terminal-input-line">
                <span class="terminal-prompt" id="terminal-prompt">developer@git-workstation:~/project_üëç$</span>
                <input type="text" class="terminal-input" id="terminal-input" placeholder="Type command here..." autocomplete="off">
            </div>
            <div class="terminal-resize-handle"></div>
        </div>
    </div>

    <!-- Import browser-compatible core modules -->
    <script src="git-timeline-browser.js"></script>
    <script src="git-command-processor-browser.js"></script>
    
    <script>
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Create Git command processor
            const gitProcessor = new GitCommandProcessor();
            
            // Make available globally
            window.gitProcessor = gitProcessor;
            
            // Initialize event listeners
            initializeEventListeners();
            
            // Add initial welcome message
            gitProcessor.addTerminalOutput('Git Timeline Visualizer initialized.', 'info');
            gitProcessor.addTerminalOutput('Type "git init" to start or use quick commands.', 'info');
            updateTerminal();
            
            // Initialize storage areas
            updateStorageAreas();
        });
        
        function initializeEventListeners() {
            // Main command buttons
            document.querySelectorAll('.main-cmd-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all buttons
                    document.querySelectorAll('.main-cmd-btn').forEach(b => b.classList.remove('active'));
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Show auxiliary commands
                    showAuxiliaryCommands(this.dataset.cmd);
                });
            });
            
            // Terminal input
            const terminalInput = document.getElementById('terminal-input');
            terminalInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const command = this.value.trim();
                    if (command) {
                        executeCommand(command);
                        this.value = '';
                    }
                }
            });
        }
        
        function showAuxiliaryCommands(mainCmd) {
            const auxContainer = document.getElementById('auxiliary-commands');
            const commands = getAuxiliaryCommands(mainCmd);
            
            // Clear container
            auxContainer.innerHTML = '';
            
            // Add header
            const header = document.createElement('h4');
            header.textContent = 'git ' + mainCmd;
            auxContainer.appendChild(header);
            
            // Add command buttons
            commands.forEach(cmd => {
                const button = document.createElement('button');
                button.className = 'aux-cmd-btn';
                button.textContent = cmd;
                button.onclick = () => executeCommand(cmd);
                auxContainer.appendChild(button);
            });
        }
        
        function getAuxiliaryCommands(mainCmd) {
            const sessionData = window.gitProcessor.sessionData;
            
            const commands = {
                'init': ['git init .'],
                'add': [
                    'git add .',
                    'git add ' + (sessionData.lastFileName || ''),
                    'git add *.py',
                    'git add *.js',
                    'git add *.html'
                ],
                'commit': [
                    'git commit -m "' + (sessionData.lastCommitMessage || '') + '"',
                    'git commit -m "Fix bug"',
                    'git commit -m "Add new feature"',
                    'git commit -m "Update documentation"'
                ],
                'branch': [
                    'git branch',
                    'git branch ' + (sessionData.lastBranchName || ''),
                    'git branch -d ' + (sessionData.lastBranchName || ''),
                    'git branch -m old new'
                ],
                'switch': [
                    'git switch ' + (sessionData.lastBranchName || ''),
                    'git switch -c ' + (sessionData.lastBranchName || '') + '-new',
                    'git switch ~',
                    'git switch main'
                ],
                'merge': [
                    'git merge ' + (sessionData.lastBranchName || ''),
                    'git merge --abort'
                ],
                'remote': [
                    'git remote -v',
                    'git remote add origin ' + (sessionData.lastRemoteUrl || ''),
                    'git remote remove origin',
                    'git remote set-url origin ' + (sessionData.lastRemoteUrl || '')
                ],
                'pull': [
                    'git pull',
                    'git pull origin main',
                    'git pull origin ' + (sessionData.lastBranchName || '')
                ],
                'push': [
                    'git push origin main',
                    'git push origin ' + (sessionData.lastBranchName || ''),
                    'git push -u origin main'
                ],
                'config': [
                    'git config --global user.name "' + (sessionData.lastUserName || '') + '"',
                    'git config --global user.email "' + (sessionData.lastUserEmail || '') + '"',
                    'git config --global user.name "Your Name"',
                    'git config --global user.email "your.email@example.com"'
                ],
                'log': [
                    'git log --oneline',
                    'git log -n 5',
                    'git log --graph'
                ],
                'reset': [
                    'git reset HEAD~1',
                    'git reset --soft HEAD~1'
                ],
                'clone': [
                    'git clone ' + (sessionData.lastRemoteUrl || ''),
                    'git clone https://github.com/user/repo.git'
                ]
            };
            
            return commands[mainCmd] || [];
        }
        
        async function executeCommand(command) {
            if (window.gitProcessor) {
                await window.gitProcessor.processCommand(command);
                updateTerminal();
                updateTimeline();
                updateTimelineLog(command);
                updateStorageAreas(); // Update storage areas after each command
            }
        }
        
        function updateTerminal() {
            const terminalContent = document.getElementById('terminal-output');
            const output = window.gitProcessor.getTerminalOutput();
            
            terminalContent.innerHTML = output.map(entry => {
                let className = 'terminal-line';
                if (entry.type === 'error') className += ' error';
                if (entry.type === 'success') className += ' success';
                if (entry.type === 'info') className += ' info';
                if (entry.type === 'command') className += ' command';
                
                return `<div class="${className}">${entry.message}</div>`;
            }).join('');
            
            terminalContent.scrollTop = terminalContent.scrollHeight;
        }
        
        function updateTimelineLog(command) {
            const timelineLog = document.getElementById('timeline-log');
            if (!timelineLog) return;
            
            // Get the most recent timeline data
            const timelineData = window.gitProcessor.timeline.getTimelineData();
            const allNodes = Array.from(timelineData.nodes.values());
            
            if (allNodes.length === 0) {
                timelineLog.innerHTML = '<div class="no-logs">No Git commands executed yet.</div>';
                return;
            }
            
            // Get the most recent node (last one in the array)
            const latestNode = allNodes[allNodes.length - 1];
            
            // Create log entry
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${latestNode.type}`;
            
            // Format time
            const time = new Date(latestNode.timestamp).toLocaleTimeString();
            
            // Get terminal output to check for errors and extract details
            const terminalOutput = window.gitProcessor.getTerminalOutput();
            const lastOutput = terminalOutput[terminalOutput.length - 1];
            const hasError = lastOutput && lastOutput.type === 'error';
            
            // Get detailed description based on command and results
            let description = '';
            const commandParts = command.trim().split(' ');
            const mainCommand = commandParts[1];
            
            if (hasError) {
                description = `‚ùå ${lastOutput.message || 'Command failed'}`;
            } else {
                // Additional check for specific error messages that might not be marked as 'error' type
                if (lastOutput && lastOutput.message) {
                    const errorMsg = lastOutput.message;
                    if (errorMsg.includes('nothing to commit') || 
                        errorMsg.includes('fatal: not a git repository') ||
                        errorMsg.includes('fatal:') ||
                        errorMsg.includes('error:')) {
                        description = `‚ùå ${errorMsg}`;
                        return; // Skip the switch statement for errors
                    }
                }
                
                switch (mainCommand) {
                    case 'init':
                        if (commandParts.includes('--bare')) {
                            description = 'üÜï Initialized a new bare Git repository';
                        } else if (commandParts.length > 2) {
                            description = `üÜï Initialized Git repository in "${commandParts[2]}"`;
                        } else {
                            description = 'üÜï Initialized a new Git repository in current directory';
                        }
                        break;
                        
                    case 'add':
                        if (commandParts.includes('.')) {
                            description = 'üìÅ Added all files to staging area';
                        } else if (commandParts.includes('-A')) {
                            description = 'üìÅ Added all files including deletions to staging area';
                        } else if (commandParts.includes('-p')) {
                            description = 'üìù Added selected patches to staging area interactively';
                        } else {
                            const files = commandParts.slice(2).join(', ');
                            description = `üìÑ Added "${files}" to staging area`;
                        }
                        break;
                        
                    case 'commit':
                        const commitMatch = command.match(/-m\s+"([^"]+)"/);
                        const commitMessage = commitMatch ? commitMatch[1] : 'No message';
                        if (latestNode.data.shortHash) {
                            description = `‚úÖ Created commit ${latestNode.data.shortHash}: "${commitMessage}"`;
                        } else {
                            description = `‚úÖ Created commit: "${commitMessage}"`;
                        }
                        break;
                        
                    case 'branch':
                        if (commandParts.includes('-d') || commandParts.includes('-D')) {
                            const branchName = commandParts[commandParts.indexOf('-d') + 1] || commandParts[commandParts.indexOf('-D') + 1];
                            description = `üóëÔ∏è Deleted branch "${branchName}"`;
                        } else if (commandParts.includes('-m')) {
                            const oldName = commandParts[commandParts.indexOf('-m') + 1];
                            const newName = commandParts[commandParts.indexOf('-m') + 2];
                            description = `üîÑ Renamed branch "${oldName}" to "${newName}"`;
                        } else if (commandParts.includes('-a')) {
                            description = 'üìã Listed all branches (local and remote)';
                        } else if (commandParts.length > 2) {
                            description = `üåø Created new branch "${commandParts[2]}"`;
                        } else {
                            description = 'üìã Listed all local branches';
                        }
                        break;
                        
                    case 'switch':
                    case 'checkout':
                        if (commandParts.includes('-c')) {
                            const branchName = commandParts[commandParts.indexOf('-c') + 1];
                            description = `üåø Created and switched to new branch "${branchName}"`;
                        } else if (commandParts[2] === '-') {
                            description = 'üîÑ Switched to previous branch';
                        } else {
                            const branchName = commandParts[2];
                            description = `üîÑ Switched from current branch to "${branchName}"`;
                        }
                        break;
                        
                    case 'merge':
                        const branchName = commandParts[2];
                        if (commandParts.includes('--no-ff')) {
                            description = `üîÄ Merged "${branchName}" into current branch (no fast-forward)`;
                        } else if (commandParts.includes('--abort')) {
                            description = '‚ùå Aborted merge operation';
                        } else {
                            description = `üîÄ Merged "${branchName}" into current branch`;
                        }
                        break;
                        
                    case 'pull':
                        if (commandParts.length > 2) {
                            const remote = commandParts[2];
                            const branch = commandParts[3] || 'main';
                            description = `‚¨áÔ∏è Pulled changes from "${remote}/${branch}"`;
                        } else {
                            description = '‚¨áÔ∏è Pulled changes from default remote';
                        }
                        break;
                        
                    case 'push':
                        if (commandParts.includes('-u')) {
                            const remote = commandParts[2];
                            const branch = commandParts[3];
                            description = `‚¨ÜÔ∏è Pushed "${branch}" to "${remote}" and set upstream`;
                        } else if (commandParts.includes('--force')) {
                            const remote = commandParts[2];
                            const branch = commandParts[3];
                            description = `‚¨ÜÔ∏è Force pushed "${branch}" to "${remote}"`;
                        } else if (commandParts.length > 2) {
                            const remote = commandParts[2];
                            const branch = commandParts[3];
                            description = `‚¨ÜÔ∏è Pushed "${branch}" to "${remote}"`;
                        } else {
                            description = '‚¨ÜÔ∏è Pushed changes to default remote';
                        }
                        break;
                        
                    case 'remote':
                        if (commandParts.includes('add')) {
                            const name = commandParts[commandParts.indexOf('add') + 1];
                            const url = commandParts[commandParts.indexOf('add') + 2];
                            description = `üåê Added remote "${name}" pointing to ${url}`;
                        } else if (commandParts.includes('remove')) {
                            const name = commandParts[commandParts.indexOf('remove') + 1];
                            description = `üóëÔ∏è Removed remote "${name}"`;
                        } else if (commandParts.includes('-v')) {
                            description = 'üìã Listed all remotes with URLs';
                        } else {
                            description = 'üåê Remote operation completed';
                        }
                        break;
                        
                    case 'clone':
                        const url = commandParts[2];
                        const targetDir = commandParts[3];
                        if (targetDir) {
                            description = `üì• Cloned repository from ${url} into "${targetDir}"`;
                        } else {
                            description = `üì• Cloned repository from ${url}`;
                        }
                        break;
                        
                    case 'config':
                        if (commandParts.includes('--global')) {
                            if (command.includes('user.name')) {
                                const nameMatch = command.match(/user\.name\s+"([^"]+)"/);
                                const name = nameMatch ? nameMatch[1] : 'updated';
                                description = `‚öôÔ∏è Set global user name to "${name}"`;
                            } else if (command.includes('user.email')) {
                                const emailMatch = command.match(/user\.email\s+"([^"]+)"/);
                                const email = emailMatch ? emailMatch[1] : 'updated';
                                description = `‚öôÔ∏è Set global user email to "${email}"`;
                            } else {
                                description = '‚öôÔ∏è Updated global Git configuration';
                            }
                        } else {
                            description = '‚öôÔ∏è Updated Git configuration';
                        }
                        break;
                        
                    case 'log':
                        if (commandParts.includes('--oneline')) {
                            description = 'üìú Displayed commit history in compact format';
                        } else if (commandParts.includes('--graph')) {
                            description = 'üìú Displayed commit history with branch graph';
                        } else if (commandParts.includes('-n')) {
                            const count = commandParts[commandParts.indexOf('-n') + 1];
                            description = `üìú Displayed last ${count} commits`;
                        } else {
                            description = 'üìú Displayed full commit history';
                        }
                        break;
                        
                    case 'reset':
                        if (commandParts.includes('--hard')) {
                            const ref = commandParts[commandParts.indexOf('--hard') + 1] || 'HEAD';
                            description = `üîÑ Hard reset to ${ref} (discarded all changes)`;
                        } else if (commandParts.includes('--soft')) {
                            const ref = commandParts[commandParts.indexOf('--soft') + 1] || 'HEAD';
                            description = `üîÑ Soft reset to ${ref} (kept changes staged)`;
                        } else {
                            const ref = commandParts[2] || 'HEAD';
                            description = `üîÑ Mixed reset to ${ref} (unstaged changes)`;
                        }
                        break;
                        
                    case 'status':
                        description = 'üìä Checked repository status';
                        break;
                        
                    default:
                        description = `‚ö° Executed: ${command}`;
                }
            }
            
            logEntry.innerHTML = `
                <div class="log-time">${time}</div>
                <div class="log-command">${command}</div>
                <div class="log-description">${description}</div>
            `;
            
            // Remove the "no logs" message if it exists
            const noLogs = timelineLog.querySelector('.no-logs');
            if (noLogs) {
                noLogs.remove();
            }
            
            // Add the new entry at the top
            timelineLog.insertBefore(logEntry, timelineLog.firstChild);
            
            // Limit to 20 most recent entries
            const entries = timelineLog.querySelectorAll('.log-entry');
            if (entries.length > 20) {
                entries[entries.length - 1].remove();
            }
        }
        
        function updateTimeline() {
            const timelineData = window.gitProcessor.timeline.getTimelineData();
            
            // Update the animation console with Git branching visualization
            renderGitGraph(timelineData);
        }
        
        // Git Graph Visualization System
        class GitGraphVisualizer {
            constructor() {
                this.svg = document.getElementById('branch-visualizer');
                this.nodesContainer = document.getElementById('commit-nodes');
                this.timelineContainer = document.querySelector('.timeline-container');
                this.branchYPositions = new Map();
                this.commitSpacing = 150;
                this.branchSpacing = 80;
                this.currentX = 50;
                this.nodeElements = new Map();
                this.edgeElements = new Map();
                this.branchColors = {
                    'main': '#4ecdc4',
                    'master': '#4ecdc4', 
                    'develop': '#ff6b6b',
                    'feature': '#feca57',
                    'hotfix': '#ff9ff3',
                    'release': '#54a0ff',
                    'remote': '#48dbfb'
                };
                
                // Zoom and pan state
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.isDragging = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                
                this.initializeInteractions();
            }
            
            initializeInteractions() {
                if (!this.svg) return;
                
                // Mouse wheel zoom
                this.svg.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.setZoom(this.zoom * delta);
                });
                
                // Mouse drag pan
                this.svg.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.dragStartX = e.clientX - this.panX;
                    this.dragStartY = e.clientY - this.panY;
                    this.svg.style.cursor = 'grabbing';
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        this.panX = e.clientX - this.dragStartX;
                        this.panY = e.clientY - this.dragStartY;
                        this.updateTransform();
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.svg.style.cursor = 'grab';
                });
            }
            
            setZoom(newZoom) {
                this.zoom = Math.min(Math.max(newZoom, 0.3), 3);
                this.updateTransform();
            }
            
            updateTransform() {
                const transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.zoom})`;
                if (this.svg) {
                    this.svg.style.transform = transform;
                }
                if (this.nodesContainer) {
                    this.nodesContainer.style.transform = transform;
                }
            }
            
            resetView() {
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.updateTransform();
            }
            
            centerView() {
                if (!this.timelineContainer) return;
                
                const containerRect = this.timelineContainer.getBoundingClientRect();
                const contentWidth = this.currentX + 100;
                const contentHeight = (this.branchYPositions.size * this.branchSpacing) + 200;
                
                // Calculate center offsets
                this.panX = (containerRect.width - contentWidth * this.zoom) / 2;
                this.panY = (containerRect.height - contentHeight * this.zoom) / 2;
                
                this.updateTransform();
            }
            
            getBranchColor(branchName) {
                // Generate color based on branch name hash for consistency
                if (this.branchColors[branchName]) {
                    return this.branchColors[branchName];
                }
                
                let hash = 0;
                for (let i = 0; i < branchName.length; i++) {
                    hash = branchName.charCodeAt(i) + ((hash << 5) - hash);
                }
                
                const colors = ['#ff6b6b', '#feca57', '#ff9ff3', '#54a0ff', '#48dbfb', '#1dd1a1', '#ff6348', '#30336b'];
                return colors[Math.abs(hash) % colors.length];
            }
            
            getBranchYPosition(branchName) {
                if (!this.branchYPositions.has(branchName)) {
                    const index = this.branchYPositions.size;
                    this.branchYPositions.set(branchName, 100 + (index * this.branchSpacing));
                }
                return this.branchYPositions.get(branchName);
            }
            
            clearVisualization() {
                if (this.svg) {
                    this.svg.innerHTML = '';
                }
                if (this.nodesContainer) {
                    this.nodesContainer.innerHTML = '';
                }
                this.nodeElements.clear();
                this.edgeElements.clear();
                this.branchYPositions.clear();
                this.currentX = 50;
            }
            
            render(timelineData) {
                if (!timelineData.nodes || timelineData.nodes.length === 0) {
                    this.showEmptyState();
                    return;
                }
                
                // Only clear if this is the first render or if we have significantly different data
                if (this.nodeElements.size === 0) {
                    this.clearVisualization();
                }
                
                // Group nodes by branch and calculate positions
                const branchNodes = this.groupNodesByBranch(timelineData.nodes);
                const nodePositions = this.calculateNodePositions(branchNodes);
                
                // Draw branch lines first (background)
                this.drawBranchLines(branchNodes, nodePositions);
                
                // Update branch line styles based on current branch
                this.updateBranchLineStyles();
                
                // Draw edges/connections
                this.drawEdges(timelineData.edges, nodePositions);
                
                // Draw only new commit nodes (incremental rendering)
                this.drawNewCommitNodes(timelineData.nodes, nodePositions);
                
                // Add current HEAD indicator - use the new radio button HEAD tracking
                this.drawHeadIndicator(timelineData.nodes, nodePositions);
                
                // Auto-center the view
                setTimeout(() => this.centerView(), 100);
            }
            
            showEmptyState() {
                if (this.nodesContainer) {
                    this.nodesContainer.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; flex-direction: column; gap: 15px; padding: 40px;">
                            <div style="font-size: 1.1em; color: #999; font-family: monospace;">
                                Type "git init" to start
                            </div>
                            <div style="font-size: 0.9em; color: #aaa; text-align: center;">
                                Git state machine visualization will appear here
                            </div>
                            <div style="font-size: 0.8em; color: #bbb; text-align: center; max-width: 300px;">
                                Nodes show repository states ‚Ä¢ Edges show Git commands
                            </div>
                        </div>
                    `;
                }
                
                // Add arrow marker definition to SVG
                if (this.svg) {
                    const svgNS = 'http://www.w3.org/2000/svg';
                    const defs = document.createElementNS(svgNS, 'defs');
                    
                    const marker = document.createElementNS(svgNS, 'marker');
                    marker.setAttribute('id', 'arrowhead');
                    marker.setAttribute('markerWidth', '10');
                    marker.setAttribute('markerHeight', '7');
                    marker.setAttribute('refX', '9');
                    marker.setAttribute('refY', '3.5');
                    marker.setAttribute('orient', 'auto');
                    
                    const polygon = document.createElementNS(svgNS, 'polygon');
                    polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                    polygon.setAttribute('fill', '#666');
                    
                    marker.appendChild(polygon);
                    defs.appendChild(marker);
                    this.svg.appendChild(defs);
                }
            }
            
            groupNodesByBranch(nodes) {
                const branchNodes = new Map();
                let currentBranch = 'main'; // Default to main
                
                // Create a timeline of branch context changes
                const branchTimeline = [];
                
                // Nodes are already sorted chronologically from getTimelineData
                
                nodes.forEach((node, index) => {
                    let branch = currentBranch;
                    
                    // Track branch context changes
                    if (node.type === 'branch' && node.data.branch) {
                        // Branch creation - creates new branch but doesn't switch to it
                        branchTimeline.push({
                            timestamp: node.timestamp,
                            type: 'create_branch',
                            branch: node.data.branch,
                            currentBranch: currentBranch
                        });
                    }
                    
                    if (node.type === 'switch' && node.data.branch) {
                        // Branch switch - changes current branch context
                        currentBranch = node.data.branch;
                        branchTimeline.push({
                            timestamp: node.timestamp,
                            type: 'switch_branch',
                            branch: currentBranch,
                            currentBranch: currentBranch
                        });
                    }
                    
                    // Determine which branch this node belongs to
                    if (node.type === 'branch' && node.data.branch) {
                        branch = node.data.branch; // Branch creation node belongs to its own branch
                    } else if (node.type === 'switch') {
                        branch = node.data.branch; // Switch node belongs to target branch
                    } else {
                        branch = currentBranch; // All other operations follow current branch
                    }
                    
                    if (!branchNodes.has(branch)) {
                        branchNodes.set(branch, []);
                    }
                    branchNodes.get(branch).push(node);
                });
                
                return branchNodes;
            }
            
            calculateNodePositions(branchNodes) {
                const positions = new Map();
                let maxX = 50;
                
                // First, position main branch nodes (they start from left)
                const mainBranchNodes = branchNodes.get('main') || [];
                mainBranchNodes.forEach((node, index) => {
                    const x = 50 + (index * this.commitSpacing);
                    const y = this.getBranchYPosition('main');
                    positions.set(node.id, { x, y, branch: 'main' });
                    maxX = Math.max(maxX, x);
                });
                
                // Then position other branches starting from their creation point
                branchNodes.forEach((nodes, branchName) => {
                    if (branchName === 'main') return; // Skip main, already positioned
                    
                    const y = this.getBranchYPosition(branchName);
                    
                    nodes.forEach((node, index) => {
                        let x;
                        
                        if (node.type === 'branch' && node.data.branch === branchName) {
                            // Branch creation node - position at current HEAD position
                            const headPos = this.findHeadPosition(positions, branchNodes);
                            x = headPos.x;
                        } else {
                            // Other nodes on this branch - continue from branch creation point
                            const branchCreationNode = nodes.find(n => n.type === 'branch' && n.data.branch === branchName);
                            if (branchCreationNode) {
                                const creationPos = positions.get(branchCreationNode.id);
                                x = creationPos.x + ((index - nodes.indexOf(branchCreationNode)) * this.commitSpacing);
                            } else {
                                // Fallback - position from left
                                x = 50 + (index * this.commitSpacing);
                            }
                        }
                        
                        positions.set(node.id, { x, y, branch: branchName });
                        maxX = Math.max(maxX, x);
                    });
                });
                
                this.currentX = maxX;
                return positions;
            }
            
            findHeadPosition(positions, branchNodes) {
                // Find the current HEAD position (rightmost node on current branch)
                let headX = 50;
                let headY = this.getBranchYPosition('main');
                
                // Look for the rightmost node that should be the HEAD
                for (const [nodeId, pos] of positions.entries()) {
                    if (pos.x > headX) {
                        headX = pos.x;
                        headY = pos.y;
                    }
                }
                
                return { x: headX, y: headY };
            }
            
            drawBranchLines(branchNodes, nodePositions) {
                if (!this.svg) return;
                
                const svgNS = 'http://www.w3.org/2000/svg';
                
                branchNodes.forEach((nodes, branchName) => {
                    if (nodes.length === 0) return;
                    
                    const y = this.getBranchYPosition(branchName);
                    const color = this.getBranchColor(branchName);
                    
                    let startX = 30;
                    
                    // For non-main branches, start line from branch creation point
                    if (branchName !== 'main') {
                        const branchCreationNode = nodes.find(n => n.type === 'branch' && n.data.branch === branchName);
                        if (branchCreationNode) {
                            const creationPos = nodePositions.get(branchCreationNode.id);
                            if (creationPos) {
                                startX = creationPos.x;
                            }
                        }
                    }
                    
                    // Find the rightmost position for this branch
                    let rightmostX = startX;
                    for (const [nodeId, pos] of nodePositions.entries()) {
                        if (pos.branch === branchName && pos.x > rightmostX) {
                            rightmostX = pos.x;
                        }
                    }
                    
                    // Check if branch line already exists
                    const existingLine = this.svg.querySelector(`[data-branch="${branchName}"]`);
                    if (existingLine) {
                        // Update existing line to extend further if needed
                        existingLine.setAttribute('x2', rightmostX + 40);
                        return;
                    }
                    
                    // Draw new branch line from start to rightmost node
                    const line = document.createElementNS(svgNS, 'line');
                    line.setAttribute('data-branch', branchName); // Mark for future updates
                    line.setAttribute('x1', startX);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', rightmostX + 40); // Extend past last node
                    line.setAttribute('y2', y);
                    
                    // Set branch line style based on whether it's the current branch
                    const currentBranch = window.gitProcessor ? window.gitProcessor.timeline.getCurrentBranch() : 'main';
                    const isCurrentBranch = branchName === currentBranch;
                    
                    if (isCurrentBranch) {
                        // Current branch: full color, visible
                        line.setAttribute('stroke', color);
                        line.setAttribute('stroke-width', '3');
                        line.setAttribute('opacity', '0.6');
                        line.style.filter = `drop-shadow(0 0 3px ${color})`;
                    } else {
                        // Non-current branch: grey, less visible
                        line.setAttribute('stroke', '#666');
                        line.setAttribute('stroke-width', '2');
                        line.setAttribute('opacity', '0.2');
                        line.style.filter = 'none';
                    }
                    
                    this.svg.appendChild(line);
                    
                    // Add branch label at the right end
                    const text = document.createElementNS(svgNS, 'text');
                    text.setAttribute('data-branch-label', branchName);
                    text.setAttribute('x', rightmostX + 45);
                    text.setAttribute('y', y);
                    text.setAttribute('text-anchor', 'start');
                    text.setAttribute('font-size', '12');
                    text.setAttribute('font-weight', isCurrentBranch ? 'bold' : 'normal');
                    text.setAttribute('fill', isCurrentBranch ? color : '#999');
                    text.style.filter = isCurrentBranch ? `drop-shadow(0 0 3px ${color})` : 'none';
                    text.textContent = branchName;
                    
                    this.svg.appendChild(text);
                });
            }
            
            updateBranchLineStyles() {
                if (!this.svg) return;
                
                const currentBranch = window.gitProcessor ? window.gitProcessor.timeline.getCurrentBranch() : 'main';
                
                // Update all branch lines
                document.querySelectorAll('[data-branch]').forEach(line => {
                    const branchName = line.getAttribute('data-branch');
                    const color = this.getBranchColor(branchName);
                    const isCurrentBranch = branchName === currentBranch;
                    
                    if (isCurrentBranch) {
                        // Current branch: full color, visible
                        line.setAttribute('stroke', color);
                        line.setAttribute('stroke-width', '3');
                        line.setAttribute('opacity', '0.6');
                        line.style.filter = `drop-shadow(0 0 3px ${color})`;
                    } else {
                        // Non-current branch: grey, less visible
                        line.setAttribute('stroke', '#666');
                        line.setAttribute('stroke-width', '2');
                        line.setAttribute('opacity', '0.2');
                        line.style.filter = 'none';
                    }
                });
                
                // Update all branch labels
                document.querySelectorAll('[data-branch-label]').forEach(text => {
                    const branchName = text.getAttribute('data-branch-label');
                    const color = this.getBranchColor(branchName);
                    const isCurrentBranch = branchName === currentBranch;
                    
                    text.setAttribute('font-weight', isCurrentBranch ? 'bold' : 'normal');
                    text.setAttribute('fill', isCurrentBranch ? color : '#999');
                    text.style.filter = isCurrentBranch ? `drop-shadow(0 0 3px ${color})` : 'none';
                });
            }
            
            drawEdges(edges, nodePositions) {
                if (!this.svg) return;
                
                const svgNS = 'http://www.w3.org/2000/svg';
                
                edges.forEach((edge, index) => {
                    // Skip if this edge already exists
                    if (this.edgeElements.has(edge.id)) {
                        return;
                    }
                    
                    const fromPos = nodePositions.get(edge.from);
                    const toPos = nodePositions.get(edge.to);
                    
                    if (!fromPos || !toPos) return;
                    
                    // Create curved path for edges
                    const midX = (fromPos.x + toPos.x) / 2;
                    const controlY = Math.min(fromPos.y, toPos.y) - 30;
                    
                    const d = `M ${fromPos.x} ${fromPos.y} Q ${midX} ${controlY} ${toPos.x} ${toPos.y}`;
                    
                    const path = document.createElementNS(svgNS, 'path');
                    path.setAttribute('d', d);
                    
                    // Basic edge styling
                    path.setAttribute('stroke', '#666');
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('opacity', '0.8');
                    path.style.cursor = 'pointer';
                    
                    // Add arrow marker
                    path.setAttribute('marker-end', 'url(#arrowhead)');
                    
                    this.svg.appendChild(path);
                    
                    // Add command label only for important operations
                    if (edge.command && (edge.command.includes('commit') || edge.command.includes('merge') || edge.command.includes('push') || edge.command.includes('pull'))) {
                        const commandText = edge.command || 'transition';
                        const displayText = this.truncateCommand(commandText, 15);
                        
                        // Add command label on the edge
                        const text = document.createElementNS(svgNS, 'text');
                        text.setAttribute('x', midX);
                        text.setAttribute('y', controlY);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '10');
                        text.setAttribute('font-family', 'monospace');
                        text.setAttribute('fill', '#333');
                        text.setAttribute('font-weight', 'bold');
                        text.style.cursor = 'pointer';
                        text.textContent = displayText;
                        
                        // Add background rectangle
                        const rect = document.createElementNS(svgNS, 'rect');
                        const bbox = text.getBBox();
                        rect.setAttribute('x', bbox.x - 4);
                        rect.setAttribute('y', bbox.y - 2);
                        rect.setAttribute('width', bbox.width + 8);
                        rect.setAttribute('height', bbox.height + 4);
                        rect.setAttribute('fill', 'white');
                        rect.setAttribute('stroke', '#ddd');
                        rect.setAttribute('stroke-width', '1');
                        rect.setAttribute('rx', '3');
                        rect.style.cursor = 'pointer';
                        
                        // Add click interaction
                        const edgeGroup = document.createElementNS(svgNS, 'g');
                        edgeGroup.appendChild(rect);
                        edgeGroup.appendChild(text);
                        
                        edgeGroup.dataset.fullCommand = commandText;
                        edgeGroup.dataset.edgeId = edge.id;
                        
                        edgeGroup.addEventListener('click', () => {
                            this.toggleEdgeDetails(edge.id, commandText, midX, controlY);
                        });
                        
                        edgeGroup.addEventListener('mouseenter', () => {
                            if (!this.activeEdgeDetails || this.activeEdgeDetails !== edge.id) {
                                edgeGroup.title = commandText;
                            }
                        });
                        
                        this.svg.appendChild(edgeGroup);
                        this.edgeElements.set(edge.id, { path, group: edgeGroup, text, rect });
                    } else {
                        this.edgeElements.set(edge.id, { path });
                    }
                });
            }
            
            truncateCommand(command, maxLength) {
                if (command.length <= maxLength) return command;
                return command.substring(0, maxLength - 3) + '...';
            }
            
            toggleEdgeDetails(edgeId, fullCommand, x, y) {
                // Remove existing details if showing different edge
                if (this.activeEdgeDetails && this.activeEdgeDetails !== edgeId) {
                    this.removeEdgeDetails();
                }
                
                // Toggle details for current edge
                if (this.activeEdgeDetails === edgeId) {
                    this.removeEdgeDetails();
                } else {
                    this.showEdgeDetails(edgeId, fullCommand, x, y);
                }
            }
            
            showEdgeDetails(edgeId, fullCommand, x, y) {
                const svgNS = 'http://www.w3.org/2000/svg';
                
                // Create detailed text
                const detailText = document.createElementNS(svgNS, 'text');
                detailText.setAttribute('x', x);
                detailText.setAttribute('y', y);
                detailText.setAttribute('text-anchor', 'middle');
                detailText.setAttribute('font-size', '11');
                detailText.setAttribute('font-family', 'monospace');
                detailText.setAttribute('fill', '#000');
                detailText.setAttribute('font-weight', 'bold');
                detailText.textContent = fullCommand;
                
                // Create background for detailed text
                const bbox = detailText.getBBox();
                const detailRect = document.createElementNS(svgNS, 'rect');
                detailRect.setAttribute('x', bbox.x - 6);
                detailRect.setAttribute('y', bbox.y - 3);
                detailRect.setAttribute('width', bbox.width + 12);
                detailRect.setAttribute('height', bbox.height + 6);
                detailRect.setAttribute('fill', '#fff');
                detailRect.setAttribute('stroke', '#333');
                detailRect.setAttribute('stroke-width', '2');
                detailRect.setAttribute('rx', '4');
                
                // Create group for details
                const detailGroup = document.createElementNS(svgNS, 'g');
                detailGroup.id = `edge-details-${edgeId}`;
                detailGroup.appendChild(detailRect);
                detailGroup.appendChild(detailText);
                
                this.svg.appendChild(detailGroup);
                this.activeEdgeDetails = edgeId;
            }
            
            removeEdgeDetails() {
                if (this.activeEdgeDetails) {
                    const detailElement = document.getElementById(`edge-details-${this.activeEdgeDetails}`);
                    if (detailElement) {
                        detailElement.remove();
                    }
                    this.activeEdgeDetails = null;
                }
            }
            
            drawNewCommitNodes(nodes, nodePositions) {
                if (!this.nodesContainer) return;
                
                nodes.forEach((node, index) => {
                    // Skip if this node already exists
                    if (this.nodeElements.has(node.id)) {
                        return;
                    }
                    
                    // Skip switch nodes (only in timeline log)
                    if (node.type === 'switch') {
                        return;
                    }
                    
                    // Skip branch listing nodes (git branch without arguments)
                    if (node.type === 'branch' && !node.data.branch) {
                        return;
                    }
                    
                    const pos = nodePositions.get(node.id);
                    if (!pos) return;
                    
                    const nodeElement = this.createCommitNode(node, pos);
                    this.nodesContainer.appendChild(nodeElement);
                    this.nodeElements.set(node.id, nodeElement);
                    
                    // Animate node appearance with staggered delay for chronological effect
                    const delay = index * 100; // 100ms delay between each node
                    this.animateNodeAppearance(nodeElement, delay);
                });
            }
            
            drawCommitNodes(nodes, nodePositions) {
                // Keep this method for backward compatibility, but use drawNewCommitNodes for incremental rendering
                this.drawNewCommitNodes(nodes, nodePositions);
            }
            
            createCommitNode(node, position) {
                const nodeDiv = document.createElement('div');
                nodeDiv.className = `state-node ${node.type}`;
                nodeDiv.style.cssText = `
                    position: absolute;
                    left: ${position.x}px;
                    top: ${position.y}px;
                    width: 80px;
                    height: 40px;
                    background: ${this.getStateColor(node.type)};
                    border: 2px solid #333;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    transform: translate(-50%, -50%);
                    z-index: 10;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 10px;
                    font-weight: bold;
                    color: white;
                    font-family: monospace;
                    border-radius: 5px;
                `;
                
                // Show state instead of command
                let stateText = this.getStateText(node);
                nodeDiv.textContent = stateText;
                
                // Add tooltip with detailed information
                nodeDiv.title = this.getStateTooltip(node);
                
                // Add hover effects
                nodeDiv.addEventListener('mouseenter', () => {
                    nodeDiv.style.transform = 'translate(-50%, -50%) scale(1.1)';
                    nodeDiv.style.zIndex = '20';
                    nodeDiv.style.borderColor = '#000';
                    nodeDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                });
                
                nodeDiv.addEventListener('mouseleave', () => {
                    nodeDiv.style.transform = 'translate(-50%, -50%) scale(1)';
                    nodeDiv.style.zIndex = '10';
                    nodeDiv.style.borderColor = '#333';
                    nodeDiv.style.boxShadow = 'none';
                });
                
                // Add click handler for details
                nodeDiv.addEventListener('click', () => {
                    this.showStateDetails(node);
                });
                
                return nodeDiv;
            }
            
            getStateText(node) {
                // Return state based on node type and data
                switch (node.type) {
                    case 'init':
                        return 'REPO INIT';
                    case 'add':
                        return 'FILES STAGED';
                    case 'commit':
                        const hash = node.data.hash ? ` ${node.data.hash.substring(0, 7)}` : '';
                        return `COMMITTED${hash}`;
                    case 'branch':
                        const branchName = node.data.branch || node.data.message || 'new';
                        return `BRANCH: ${branchName}`;
                    case 'switch':
                        return 'SWITCHED';
                    case 'merge':
                        return 'MERGED';
                    case 'push':
                        return 'PUSHED';
                    case 'pull':
                        return 'PULLED';
                    case 'clone':
                        return 'CLONED';
                    default:
                        return node.type.toUpperCase();
                }
            }
            
            getStateColor(type) {
                // Colors for different states
                const colors = {
                    'init': '#2ecc71',
                    'add': '#f39c12',
                    'commit': '#3498db',
                    'branch': '#9b59b6',
                    'switch': '#e67e22',
                    'merge': '#e74c3c',
                    'push': '#16a085',
                    'pull': '#27ae60',
                    'clone': '#2ecc71'
                };
                return colors[type] || '#95a5a6';
            }
            
            getStateTooltip(node) {
                let tooltip = `State: ${this.getStateText(node)}\n`;
                if (node.branch) tooltip += `Branch: ${node.branch}\n`;
                if (node.data.command) tooltip += `Command: ${node.data.command}\n`;
                if (node.data.message) tooltip += `Message: ${node.data.message}\n`;
                if (node.data.hash) tooltip += `Hash: ${node.data.hash}\n`;
                tooltip += `Time: ${new Date(node.timestamp).toLocaleString()}`;
                return tooltip;
            }
            
            showStateDetails(node) {
                const details = [
                    `=== STATE: ${this.getStateText(node)} ===`,
                    `Branch: ${node.branch}`,
                    `Command: ${node.data.command || 'N/A'}`,
                    `Message: ${node.data.message || 'No message'}`,
                    `Time: ${new Date(node.timestamp).toLocaleString()}`
                ];
                
                if (node.data.hash) {
                    details.push(`Hash: ${node.data.hash}`);
                }
                
                if (window.gitProcessor) {
                    details.forEach(detail => {
                        window.gitProcessor.addTerminalOutput(detail, 'info');
                    });
                }
                
                // Highlight the node temporarily
                this.highlightNode(node.id);
            }
            
            getNodeColor(type) {
                const colors = {
                    'init': 'linear-gradient(135deg, #4CAF50, #45a049)',
                    'commit': 'linear-gradient(135deg, #ff6b6b, #ff5252)',
                    'branch': 'linear-gradient(135deg, #54a0ff, #2e86de)',
                    'merge': 'linear-gradient(135deg, #ff9ff3, #ee5a6f)',
                    'push': 'linear-gradient(135deg, #feca57, #ff9ff3)',
                    'pull': 'linear-gradient(135deg, #48dbfb, #0abde3)',
                    'clone': 'linear-gradient(135deg, #1dd1a1, #10ac84)',
                    'switch': 'linear-gradient(135deg, #a55eea, #8854d0)'
                };
                return colors[type] || 'linear-gradient(135deg, #636e72, #2d3436)';
            }
            
            getNodeIcon(type) {
                const icons = {
                    'init': 'üÜï',
                    'commit': 'üìù',
                    'branch': 'üåø',
                    'merge': 'üîÄ',
                    'push': '‚¨ÜÔ∏è',
                    'pull': '‚¨áÔ∏è',
                    'clone': 'üì•',
                    'switch': 'üîÑ'
                };
                return icons[type] || 'üìç';
            }
            
            getNodeTooltip(node) {
                const time = new Date(node.timestamp).toLocaleString();
                const hash = node.data.hash ? ` (${node.data.hash.substring(0, 7)})` : '';
                return `${node.type.toUpperCase()}${hash}\n${node.data.message || 'No message'}\nBranch: ${node.branch}\n${time}`;
            }
            
            animateNodeAppearance(nodeElement, delay = 0) {
                nodeElement.style.transform = 'translate(-50%, -50%) scale(0)';
                nodeElement.style.opacity = '0';
                
                setTimeout(() => {
                    nodeElement.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                    nodeElement.style.transform = 'translate(-50%, -50%) scale(1)';
                    nodeElement.style.opacity = '1';
                }, delay);
            }
            
            drawHeadIndicator(nodes, nodePositions) {
                // First, remove any existing HEAD indicators
                this.removeExistingHeadIndicators();
                
                // Find the node that has the HEAD flag (radio button behavior)
                const headNode = nodes.find(node => node.is_head);
                if (!headNode) return;
                
                const headPos = nodePositions.get(headNode.id);
                if (!headPos) return;
                
                // Check for any errors in the last few terminal outputs
                const terminalOutput = window.gitProcessor ? window.gitProcessor.getTerminalOutput() : [];
                const recentOutputs = terminalOutput.slice(-3); // Check last 3 outputs
                
                const hasRecentError = recentOutputs.some(output => 
                    output.type === 'error' ||
                    output.message.includes('nothing to commit') ||
                    output.message.includes('fatal:') ||
                    output.message.includes('error:')
                );
                
                // Don't show HEAD if there's a recent error or no valid nodes
                if (hasRecentError || this.nodeElements.size === 0) {
                    return;
                }
                
                // Get the DOM element for the HEAD node
                const headNodeElement = this.nodeElements.get(headNode.id);
                if (!headNodeElement) return;
                
                // Create HEAD indicator above the node
                const headIndicator = document.createElement('div');
                headIndicator.className = 'head-indicator'; // Add class for easy removal
                headIndicator.style.cssText = `
                    position: absolute;
                    left: ${headPos.x}px;
                    top: ${headPos.y - 35}px;
                    background: #FFD700;
                    color: #333;
                    padding: 4px 8px;
                    border-radius: 12px;
                    font-size: 10px;
                    font-weight: bold;
                    z-index: 15;
                    transform: translateX(-50%);
                    box-shadow: 0 2px 8px rgba(255, 215, 0, 0.5);
                    animation: pulse 2s infinite;
                    font-family: monospace;
                `;
                headIndicator.textContent = 'HEAD';
                
                this.nodesContainer.appendChild(headIndicator);
            }
            
            removeExistingHeadIndicators() {
                // Remove all existing HEAD indicators
                const existingIndicators = this.nodesContainer.querySelectorAll('.head-indicator');
                existingIndicators.forEach(indicator => indicator.remove());
            }
            
            showNodeDetails(node) {
                const details = [
                    `=== ${node.type.toUpperCase()} NODE ===`,
                    `Command: ${node.data.command || 'N/A'}`,
                    `Message: ${node.data.message || 'No message'}`,
                    `Branch: ${node.branch}`,
                    `Time: ${new Date(node.timestamp).toLocaleString()}`
                ];
                
                if (node.data.hash) {
                    details.push(`Hash: ${node.data.hash}`);
                }
                
                if (window.gitProcessor) {
                    details.forEach(detail => {
                        window.gitProcessor.addTerminalOutput(detail, 'info');
                    });
                }
                
                // Highlight the node temporarily
                this.highlightNode(node.id);
            }
            
            showEdgeDetails(edge) {
                const details = [
                    `=== EDGE CONNECTION ===`,
                    `Command: ${edge.command || 'Connection'}`,
                    `From: ${edge.from}`,
                    `To: ${edge.to}`,
                    `Type: ${edge.data.type || 'standard'}`
                ];
                
                if (window.gitProcessor) {
                    details.forEach(detail => {
                        window.gitProcessor.addTerminalOutput(detail, 'info');
                    });
                }
                
                // Highlight the edge temporarily
                this.highlightEdge(edge.id);
            }
            
            highlightNode(nodeId) {
                const nodeElement = this.nodeElements.get(nodeId);
                if (nodeElement) {
                    const originalBorder = nodeElement.style.borderColor;
                    const originalTransform = nodeElement.style.transform;
                    
                    nodeElement.style.borderColor = '#ff0000';
                    nodeElement.style.transform = 'translate(-50%, -50%) scale(1.3)';
                    nodeElement.style.zIndex = '30';
                    
                    setTimeout(() => {
                        nodeElement.style.borderColor = originalBorder;
                        nodeElement.style.transform = originalTransform;
                        nodeElement.style.zIndex = '10';
                    }, 2000);
                }
            }
            
            highlightEdge(edgeId) {
                const edgeElement = this.edgeElements.get(edgeId);
                if (edgeElement) {
                    const originalStroke = edgeElement.getAttribute('stroke');
                    const originalWidth = edgeElement.getAttribute('stroke-width');
                    const originalOpacity = edgeElement.getAttribute('opacity');
                    
                    edgeElement.setAttribute('stroke', '#ff0000');
                    edgeElement.setAttribute('stroke-width', parseInt(originalWidth) + 2);
                    edgeElement.setAttribute('opacity', '1');
                    
                    setTimeout(() => {
                        edgeElement.setAttribute('stroke', originalStroke);
                        edgeElement.setAttribute('stroke-width', originalWidth);
                        edgeElement.setAttribute('opacity', originalOpacity);
                    }, 2000);
                }
            }
            
            highlightConnectedEdges(nodeId, highlight) {
                // Find and highlight edges connected to this node
                this.edgeElements.forEach((edgeElement, edgeId) => {
                    const edge = this.findEdgeById(edgeId);
                    if (edge && (edge.from === nodeId || edge.to === nodeId)) {
                        if (highlight) {
                            edgeElement.setAttribute('opacity', '1');
                            edgeElement.setAttribute('stroke-width', parseInt(edgeElement.getAttribute('stroke-width')) + 1);
                        } else {
                            edgeElement.setAttribute('opacity', '0.7');
                            edgeElement.setAttribute('stroke-width', parseInt(edgeElement.getAttribute('stroke-width')) - 1);
                        }
                    }
                });
            }
            
            findEdgeById(edgeId) {
                // This would need access to timeline data - simplified version
                return { from: '', to: '' }; // Placeholder
            }
            
            focusOnNode(nodeId) {
                const nodeElement = this.nodeElements.get(nodeId);
                if (nodeElement) {
                    // Center the view on this node
                    const nodeRect = nodeElement.getBoundingClientRect();
                    const containerRect = this.timelineContainer.getBoundingClientRect();
                    
                    // Calculate pan to center node
                    const targetX = containerRect.width / 2 - (nodeRect.left + nodeRect.width / 2) + containerRect.left;
                    const targetY = containerRect.height / 2 - (nodeRect.top + nodeRect.height / 2) + containerRect.top;
                    
                    // Smooth pan to node
                    this.panX = targetX;
                    this.panY = targetY;
                    this.updateTransform();
                    
                    // Highlight the node
                    this.highlightNode(nodeId);
                }
            }
        }
        
        // Initialize Git graph visualizer
        const gitGraphVisualizer = new GitGraphVisualizer();
        
        function renderGitGraph(timelineData) {
            gitGraphVisualizer.render(timelineData);
        }
        
        function addTimelineInteractivity() {
            const commandNodes = document.querySelectorAll('.command-node');
            const branchVisualizer = document.getElementById('branch-visualizer');
            
            // Zoom and pan state
            let zoom = 1;
            let panX = 0;
            let panY = 0;
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            
            // Add hover effects to command nodes
            commandNodes.forEach(node => {
                node.addEventListener('mouseenter', function() {
                    this.style.transform = 'scale(1.1)';
                    this.style.zIndex = '100';
                    this.querySelector('.command-info').style.opacity = '1';
                    this.querySelector('.command-info').style.transform = 'translateY(-10px)';
                });
                
                node.addEventListener('mouseleave', function() {
                    this.style.transform = 'scale(1)';
                    this.style.zIndex = '';
                    this.querySelector('.command-info').style.opacity = '0.9';
                    this.querySelector('.command-info').style.transform = 'translateY(0)';
                });
                
                // Add click interaction
                node.addEventListener('click', function() {
                    const nodeId = this.dataset.nodeId;
                    const command = this.dataset.command;
                    const message = this.dataset.message;
                    const type = this.dataset.type;
                    
                    // Show command details in terminal
                    if (window.gitProcessor) {
                        window.gitProcessor.addTerminalOutput(`\n=== Command Details ===`, 'info');
                        window.gitProcessor.addTerminalOutput(`Type: ${type.toUpperCase()}`, 'info');
                        window.gitProcessor.addTerminalOutput(`Command: ${command}`, 'info');
                        window.gitProcessor.addTerminalOutput(`Message: ${message}`, 'info');
                        
                        // Add specific details for commit nodes
                        if (type === 'commit') {
                            const hash = this.querySelector('.commit-hash').textContent.replace(' üìç', '');
                            window.gitProcessor.addTerminalOutput(`Hash: ${hash}`, 'info');
                        }
                        
                        window.gitProcessor.addTerminalOutput(`====================\n`, 'info');
                    }
                    
                    // Highlight selected node
                    document.querySelectorAll('.command-node').forEach(n => n.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            // Add zoom and pan to SVG
            branchVisualizer.addEventListener('wheel', function(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                zoom *= delta;
                zoom = Math.min(Math.max(zoom, 0.5), 3);
                updateTransform();
            });
            
            branchVisualizer.addEventListener('mousedown', function(e) {
                isDragging = true;
                dragStartX = e.clientX - panX;
                dragStartY = e.clientY - panY;
                this.style.cursor = 'grabbing';
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    panX = e.clientX - dragStartX;
                    panY = e.clientY - dragStartY;
                    updateTransform();
                }
            });
            
            document.addEventListener('mouseup', function() {
                isDragging = false;
                branchVisualizer.style.cursor = 'grab';
            });
            
            function updateTransform() {
                branchVisualizer.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
                document.getElementById('commit-nodes').style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            }
            
            // Set initial cursor
            branchVisualizer.style.cursor = 'grab';
        }
        
        function updateStorageAreas() {
            if (!window.gitProcessor) return;
            
            const timeline = window.gitProcessor.timeline;
            const currentBranch = timeline.getCurrentBranch() || 'main';
            
            // Get files from different stages based on timeline
            const workingFiles = getWorkingDirectoryFiles();
            const stagedFiles = getStagedFiles();
            const committedFiles = getCommittedFiles();
            const remoteFiles = getRemoteFiles();
            
            // Update Working Directory
            updateStage('working-files', workingFiles);
            
            // Update Staging Area
            updateStage('staged-files', stagedFiles);
            
            // Update Local Repository
            updateStage('committed-files', committedFiles);
            
            // Update Remote Repository
            updateStage('remote-files', remoteFiles);
            
            // Update file counts
            updateFileCount('stage-working', workingFiles.length);
            updateFileCount('stage-staging', stagedFiles.length);
            updateFileCount('stage-local', committedFiles.length);
            updateFileCount('stage-remote', remoteFiles.length);
        }
        
        function getWorkingDirectoryFiles() {
            // Get all files from local directory (files always stay here)
            const localFiles = window.gitProcessor.getLocalFiles() || ['index.html', 'style.css', 'script.js'];
            
            // Return files with status indicators
            return localFiles.map(file => {
                const stagedFiles = window.gitProcessor.sessionData.stagedFiles || [];
                const isStaged = stagedFiles.includes(file);
                
                return {
                    name: file,
                    status: isStaged ? 'staged' : 'modified',
                    isStaged: isStaged
                };
            });
        }
        
        function getStagedFiles() {
            // Get files from staging area
            const stagedFiles = window.gitProcessor.sessionData.stagedFiles || [];
            
            return stagedFiles.map(file => ({
                name: file,
                status: 'staged'
            }));
        }
        
        function getCommittedFiles() {
            // Get files from commit nodes and session committed files
            const commits = window.gitProcessor.timeline.getCommits();
            const files = [];
            
            // Add files from commits
            commits.forEach(commit => {
                if (commit.data.message && commit.data.message !== 'Commit') {
                    files.push({
                        name: `commit-${commit.id.slice(-6)}.txt`,
                        message: commit.data.message,
                        author: commit.data.author,
                        timestamp: commit.timestamp,
                        files: commit.data.files || []
                    });
                }
            });
            
            return files;
        }
        
        function getRemoteFiles() {
            // Get files that have been pushed
            const pushNodes = Array.from(window.gitProcessor.timeline.nodes.values())
                .filter(node => node.type === 'push');
            
            if (pushNodes.length > 0) {
                return getCommittedFiles(); // Files that were pushed
            }
            
            return [];
        }
        
        function updateStage(stageId, files) {
            const stageElement = document.getElementById(stageId);
            if (!stageElement) return;
            
            stageElement.innerHTML = '';
            
            if (files.length === 0) {
                stageElement.innerHTML = '<li class="empty-stage">No files</li>';
                return;
            }
            
            files.forEach(file => {
                const li = document.createElement('li');
                li.className = 'file-item';
                
                // Add status indicator for working directory
                let statusIcon = '<i class="fas fa-file"></i>';
                let statusClass = '';
                
                if (file.isStaged !== undefined) {
                    if (file.isStaged) {
                        statusIcon = '<i class="fas fa-check-circle" style="color: #4CAF50;"></i>';
                        statusClass = 'staged';
                    } else {
                        statusIcon = '<i class="fas fa-edit" style="color: #FF9800;"></i>';
                        statusClass = 'modified';
                    }
                }
                
                if (typeof file === 'string') {
                    li.innerHTML = `
                        ${statusIcon}
                        <span class="file-name ${statusClass}">${file}</span>
                    `;
                } else {
                    const escapedMessage = (file.message || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    const escapedAuthor = (file.author || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    const escapedName = (file.name || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    
                    li.innerHTML = `
                        ${statusIcon}
                        <span class="file-name ${statusClass}">${escapedName}</span>
                        ${file.message ? `<span class="file-message">${escapedMessage}</span>` : ''}
                        ${file.author ? `<span class="file-author">${escapedAuthor}</span>` : ''}
                        ${file.files && file.files.length > 0 ? `<span class="file-count-mini">${file.files.length} files</span>` : ''}
                    `;
                }
                
                stageElement.appendChild(li);
            });
        }
        
        function updateFileCount(stageId, count) {
            const stageElement = document.getElementById(stageId);
            if (!stageElement) return;
            
            const countElement = stageElement.querySelector('.file-count');
            if (countElement) {
                countElement.textContent = count;
            }
        }
        
        function toggleTerminal() {
            const terminal = document.getElementById('terminal');
            const toggleBtn = document.querySelector('.terminal-toggle');
            
            if (terminal.classList.contains('expanded')) {
                // If expanded, go to normal state
                terminal.classList.remove('expanded');
                terminal.classList.add('minimized');
                toggleBtn.innerHTML = '<i class="fas fa-terminal"></i> Terminal';
            } else if (terminal.classList.contains('minimized')) {
                // If minimized, go to normal state
                terminal.classList.remove('minimized');
                toggleBtn.innerHTML = '<i class="fas fa-expand"></i> Expand';
            } else {
                // If normal, go to expanded state
                terminal.classList.add('expanded');
                toggleBtn.innerHTML = '<i class="fas fa-compress"></i> Minimize';
            }
        }
        
        function clearTerminal() {
            if (window.gitProcessor) {
                window.gitProcessor.clearTerminalOutput();
                updateTerminal();
            }
        }
        
        // Graph control functions
        function zoomIn() {
            if (gitGraphVisualizer) {
                gitGraphVisualizer.setZoom(gitGraphVisualizer.zoom * 1.2);
            }
        }
        
        function zoomOut() {
            if (gitGraphVisualizer) {
                gitGraphVisualizer.setZoom(gitGraphVisualizer.zoom * 0.8);
            }
        }
        
        function resetZoom() {
            if (gitGraphVisualizer) {
                gitGraphVisualizer.resetView();
            }
        }
        
        function centerGraph() {
            if (gitGraphVisualizer) {
                gitGraphVisualizer.centerView();
            }
        }
    </script>
</body>
</html>